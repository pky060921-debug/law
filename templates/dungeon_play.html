{% extends "layout.html" %}

{% block content %}
<style>
    /* [ìŠ¤íƒ€ì¼ ì •ì˜] */
    .edit-area {
        background: rgba(0,0,0,0.3);
        padding: 25px;
        border-radius: 10px;
        border: 1px solid #5e4b3c;
        line-height: 2.8;
        font-size: 1.1rem;
        text-align: left;
        word-break: keep-all; /* ë‹¨ì–´ ë‹¨ìœ„ ì¤„ë°”ê¿ˆ */
    }

    /* í¸ì§‘ ëª¨ë“œ ë‹¨ì–´ */
    .edit-token {
        cursor: pointer;
        padding: 2px 5px;
        border-radius: 4px;
        transition: 0.2s;
        border: 1px solid transparent;
        display: inline-block; /* ì¤‘ìš”: í´ë¦­ ì˜ì—­ ì¡ê¸° */
    }
    .edit-token:hover {
        background: rgba(212, 175, 55, 0.2);
        border-color: #d4af37;
    }
    .edit-token.selected {
        background: #8b0000;
        color: #fff;
        border-color: #ff4444;
        font-weight: bold;
    }
    /* ì„ íƒëœ ë‹¨ì–´ ì•ë’¤ì— ê°€ìƒì˜ ê´„í˜¸ í‘œì‹œ (ì‹œê°ì  íš¨ê³¼) */
    .edit-token.selected::before { content: '{'; color: #ffd700; margin-right: 2px; }
    .edit-token.selected::after { content: '}'; color: #ffd700; margin-left: 2px; }

    /* ì •ì  í…ìŠ¤íŠ¸ (ì¡°ì‚¬, ë¬¸ì¥ë¶€í˜¸ ë“±) */
    .static-text {
        color: #888;
        display: inline;
    }

    /* ê²Œì„ ëª¨ë“œ ì…ë ¥ì°½ */
    .quiz-input {
        background: #222;
        border: none;
        border-bottom: 2px solid #555;
        color: white;
        text-align: center;
        font-size: 1.1rem;
        padding: 2px 0;
        margin: 0 2px;
        font-family: 'Spectral', serif;
    }
    .quiz-input:focus { outline: none; border-bottom-color: #4a90e2; background: #333; }
    .quiz-input.correct { border-bottom-color: #2ecc71; color: #2ecc71; font-weight: bold; }
    .quiz-input.error { border-bottom-color: #ff4444; color: #ff4444; animation: shake 0.3s; }

    /* ì •ë‹µ íŒíŠ¸ ë§í’ì„  */
    .answer-hint {
        display: none;
        position: absolute;
        top: -30px; left: 50%; transform: translateX(-50%);
        background: #cc0000; color: white; padding: 2px 6px;
        border-radius: 4px; font-size: 0.8rem; white-space: nowrap; z-index: 10;
    }
    .input-wrapper { position: relative; display: inline-block; }
    .input-wrapper.show-hint .answer-hint { display: block; }

    @keyframes shake { 0%,100%{transform:translateX(0);} 25%{transform:translateX(-3px);} 75%{transform:translateX(3px);} }
</style>

<div style="text-align: center;">
    {% if edit_mode %}
        <h2 style="margin-bottom:10px;">âœï¸ ë¹ˆì¹¸ ìƒì„± ëª¨ë“œ</h2>
        <p style="color:#aaa; font-size:0.9rem; margin-bottom:20px;">
            í´ë¦­í•˜ì—¬ ë¹ˆì¹¸ìœ¼ë¡œ ë§Œë“¤ ë‹¨ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”.<br>
            (ê°€ìš´ë°ì (Â·), ë§ˆì¹¨í‘œ(.) ë“±ì€ ìë™ìœ¼ë¡œ ë¶„ë¦¬ë©ë‹ˆë‹¤.)
        </p>

        <div id="edit-board" class="edit-area"></div>

        <form method="POST" id="edit-form" style="margin-top: 30px;">
            <input type="hidden" name="edited_content" id="edited_content">
            <button type="button" class="btn" onclick="submitEdit()" style="background: linear-gradient(to right, #4a90e2, #007bff); color:white;">
                ì„¤ì • ì™„ë£Œ (ì•”ê¸° ì‹œì‘)
            </button>
        </form>

    {% else %}
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <a href="/dungeon" style="text-decoration:none; color:#888;">ğŸ”™ ëª©ë¡ìœ¼ë¡œ</a>
            <div style="font-size:1.2rem; color:#d4af37;">EXP: <span id="xp-display">{{ session['xp'] }}</span></div>
        </div>

        <div class="edit-area" id="game-board">
            {% for part in parts %}
                {% if part.type == 'text' %}
                    <span class="static-text" style="color:#ccc;">{{ part.val }}</span>
                {% else %}
                    <span class="input-wrapper">
                        <span class="answer-hint">{{ targets[part.id] }}</span>
                        <input type="text" class="quiz-input" 
                               data-answer="{{ targets[part.id] }}" 
                               style="width:{{ targets[part.id]|length * 15 + 10 }}px;"
                               autocomplete="off">
                    </span>
                {% endif %}
            {% endfor %}
        </div>

        <form method="POST" id="game-form">
            <input type="hidden" name="penalty_count" id="penalty_count" value="0">
            {% for t in targets %}
                <input type="hidden" name="answers" value="{{ t }}">
            {% endfor %}
        </form>
        
        <button id="submit-btn" class="btn" onclick="checkFinal()" disabled style="background:#444; cursor:not-allowed; margin-top:30px;">
            ëª¨ë‘ ì •ë‹µì„ ë§ì¶°ì£¼ì„¸ìš”
        </button>
    {% endif %}
</div>

<script>
    /* =========================================
       [ê³µí†µ ê¸°ëŠ¥]
       ========================================= */
    
    // [A] í¸ì§‘ ëª¨ë“œ ë¡œì§ (í•µì‹¬ ìˆ˜ì • ë¶€ë¶„)
    {% if edit_mode %}
        const rawContent = `{{ raw_content | safe }}`;
        const editBoard = document.getElementById('edit-board');
        let tokenList = []; // ì „ì²´ í† í° ê´€ë¦¬

        function parseText(text) {
            const paragraphs = text.split('\n');
            let html = '';
            let globalIdx = 0;

            paragraphs.forEach(para => {
                if (!para.trim()) return;
                html += '<div style="margin-bottom:15px;">';
                
                // 1. ê³µë°±ìœ¼ë¡œ ë¨¼ì € ë‚˜ëˆ” (ì–´ì ˆ ë‹¨ìœ„)
                const chunks = para.split(/\s+/);
                
                chunks.forEach(chunk => {
                    // 2. [í•µì‹¬ ìˆ˜ì •] ì–´ì ˆ ì•ˆì—ì„œ íŠ¹ìˆ˜ë¬¸ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ë²ˆ ë” ìª¼ê°­ë‹ˆë‹¤.
                    // ì •ê·œì‹ ì„¤ëª…: ([ê°€ìš´ë°ì , ì , ì‰¼í‘œ, ê´„í˜¸ ë“± íŠ¹ìˆ˜ë¬¸ì])ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ”
                    // ìº¡ì²˜ ê·¸ë£¹ ()ì„ ì‚¬ìš©í•˜ì—¬ êµ¬ë¶„ì(íŠ¹ìˆ˜ë¬¸ì)ë„ ê²°ê³¼ ë°°ì—´ì— í¬í•¨ì‹œí‚´
                    const subTokens = chunk.split(/([Â·\.\,\(\)\{\}\[\]\<\>\:\;\!\?\"\'\~\^\-\=\+\*\/])/);

                    // ìª¼ê°œì§„ ì¡°ê°ë“¤ì„ ìˆœíšŒí•˜ë©° ì²˜ë¦¬
                    subTokens.forEach(token => {
                        if (!token) return; // ë¹ˆ ë¬¸ìì—´ ìŠ¤í‚µ

                        // íŠ¹ìˆ˜ë¬¸ìì¸ì§€ í™•ì¸ (í•œê¸€/ì˜ë¬¸/ìˆ«ìê°€ ì•„ë‹ˆë©´ íŠ¹ìˆ˜ë¬¸ìë¡œ ê°„ì£¼)
                        const isSymbol = !/[ê°€-í£a-zA-Z0-9]/.test(token);

                        if (isSymbol) {
                            // íŠ¹ìˆ˜ë¬¸ì -> ì„ íƒ ë¶ˆê°€ëŠ¥í•œ ì •ì  í…ìŠ¤íŠ¸ë¡œ ì²˜ë¦¬
                            tokenList.push({ text: token, type: 'static', selected: false });
                            html += `<span class="static-text">${token}</span>`;
                        } else {
                            // ì¼ë°˜ ë‹¨ì–´ -> ì¡°ì‚¬ ë¶„ë¦¬ ë¡œì§ ì ìš© í›„ ì„ íƒ ê°€ëŠ¥í•œ í† í°ìœ¼ë¡œ ì²˜ë¦¬
                            processWordToken(token, globalIdx);
                            // processWordToken ë‚´ë¶€ì—ì„œ html ì¶”ê°€ ë° globalIdx ì¦ê°€ ì²˜ë¦¬ë¨
                        }
                    });
                    
                    // ì–´ì ˆ ì‚¬ì´ ë„ì–´ì“°ê¸° ì¶”ê°€
                    tokenList.push({ text: ' ', type: 'space', selected: false });
                    html += ' '; 
                });
                
                html += '</div>';
            });
            editBoard.innerHTML = html;
        }

        // ë‹¨ì–´ í† í° ì²˜ë¦¬ (ì¡°ì‚¬ ë¶„ë¦¬)
        function processWordToken(word, idx) {
            let core = word;
            let suffix = "";

            // ì¡°ì‚¬ ë¶„ë¦¬ ë¡œì§
            const particles = ['ìœ¼ë¡œ', 'ì—ì„œ', 'ë¶€í„°', 'ê¹Œì§€', 'ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì—', 'ì˜', 'ì™€', 'ê³¼', 'ë¡œ', 'ë„', 'ë§Œ'];
            for (let p of particles) {
                if (core.endsWith(p) && core.length > p.length) {
                    suffix = p;
                    core = core.substring(0, core.length - p.length);
                    break;
                }
            }

            // í•µì‹¬ ë‹¨ì–´ (ì„ íƒ ê°€ëŠ¥)
            tokenList.push({ text: core, type: 'word', selected: false });
            // ì—¬ê¸°ì„œ ì „ì—­ ë°°ì—´ ì°¸ì¡°ë¥¼ ìœ„í•´ í˜„ì¬ ë°°ì—´ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜, í´ë¡œì € ë°©ì‹ ì‚¬ìš©
            // ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ HTML ìƒì„± ì‹œì ì— onclick ì´ë²¤íŠ¸ë¥¼ ë¬¸ìì—´ë¡œ ë°•ì•„ë„£ìŒ.
            // ì£¼ì˜: tokenListëŠ” ê³„ì† push ë˜ë¯€ë¡œ, í˜„ì¬ tokenListì˜ ê¸¸ì´ë¥¼ ì¸ë±ìŠ¤ë¡œ í™œìš©.
            
            const currentListIdx = tokenList.length - 1;
            
            // HTML ìƒì„±
            // 1. í•µì‹¬ ë‹¨ì–´
            htmlStr = `<span class="edit-token" onclick="toggleToken(${currentListIdx}, this)">${core}</span>`;
            
            // 2. ë¶„ë¦¬ëœ ì¡°ì‚¬ (ì„ íƒ ë¶ˆê°€)
            if (suffix) {
                tokenList.push({ text: suffix, type: 'static', selected: false });
                htmlStr += `<span class="static-text">${suffix}</span>`;
            }
            
            // ì•ì„œ í˜¸ì¶œí•œ ê³³ì˜ html ë³€ìˆ˜ì— ì´ì–´ë¶™ì´ê¸° ìœ„í•´ ì„ì‹œ ë°©í¸ ì‚¬ìš© ëŒ€ì‹ ,
            // parseText í•¨ìˆ˜ ë‚´ì—ì„œ ì§ì ‘ ì²˜ë¦¬í•˜ëŠ”ê²Œ ë‚«ì§€ë§Œ êµ¬ì¡°ìƒ í•¨ìˆ˜ ë¶„ë¦¬í•¨.
            // ì—¬ê¸°ì„œëŠ” document.writeë¥¼ ì“¸ ìˆ˜ ì—†ìœ¼ë‹ˆ parseText ë‚´ë¡œ ë¡œì§ì„ í•©ì¹˜ëŠ”ê²Œ ì•ˆì „í•˜ì§€ë§Œ,
            // ì½”ë“œ ê°€ë…ì„±ì„ ìœ„í•´ ìœ„ parseText ë£¨í”„ ì•ˆì—ì„œ ì²˜ë¦¬í•˜ë„ë¡ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.
            return { core, suffix }; 
        }

        // [ì¬ì‘ì„±ëœ parseText í•¨ìˆ˜ (ìœ„ì˜ ë¡œì§ í†µí•©)]
        parseText = function(text) {
            const paragraphs = text.split('\n');
            let html = '';
            tokenList = []; // ì´ˆê¸°í™”

            paragraphs.forEach(para => {
                if (!para.trim()) return;
                html += '<div style="margin-bottom:15px;">';
                
                const chunks = para.split(/\s+/);
                
                chunks.forEach(chunk => {
                    // ë¬¸ì¥ë¶€í˜¸ ê¸°ì¤€ 2ì°¨ ë¶„í•  (ì¤‘ìš”!)
                    const subTokens = chunk.split(/([Â·\.\,\(\)\{\}\[\]\<\>\:\;\!\?\"\'\~\^\-\=\+\*\/])/);

                    subTokens.forEach(token => {
                        if (!token) return;

                        const isSymbol = !/[ê°€-í£a-zA-Z0-9]/.test(token);

                        if (isSymbol) {
                            tokenList.push({ text: token, type: 'static', selected: false });
                            html += `<span class="static-text">${token}</span>`;
                        } else {
                            // ì¡°ì‚¬ ë¶„ë¦¬
                            let core = token;
                            let suffix = "";
                            const particles = ['ìœ¼ë¡œ', 'ì—ì„œ', 'ë¶€í„°', 'ê¹Œì§€', 'ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì—', 'ì˜', 'ì™€', 'ê³¼', 'ë¡œ', 'ë„', 'ë§Œ'];
                            
                            for (let p of particles) {
                                if (core.endsWith(p) && core.length > p.length) {
                                    suffix = p;
                                    core = core.substring(0, core.length - p.length);
                                    break;
                                }
                            }

                            // í•µì‹¬ ë‹¨ì–´ ë“±ë¡
                            const idx = tokenList.length;
                            tokenList.push({ text: core, type: 'word', selected: false });
                            html += `<span class="edit-token" onclick="toggleToken(${idx}, this)">${core}</span>`;

                            // ì¡°ì‚¬ ë“±ë¡
                            if (suffix) {
                                tokenList.push({ text: suffix, type: 'static', selected: false });
                                html += `<span class="static-text">${suffix}</span>`;
                            }
                        }
                    });
                    
                    // ë„ì–´ì“°ê¸° ë³µì›
                    tokenList.push({ text: ' ', type: 'space', selected: false });
                    html += ' '; 
                });
                
                html += '</div>';
            });
            editBoard.innerHTML = html;
        }

        function toggleToken(idx, el) {
            const token = tokenList[idx];
            token.selected = !token.selected;
            
            if (token.selected) el.classList.add('selected');
            else el.classList.remove('selected');
        }

        function submitEdit() {
            // tokenListë¥¼ ìˆœíšŒí•˜ë©° í…ìŠ¤íŠ¸ ì¬ì¡°ë¦½
            // selectedê°€ trueì¸ ê²ƒì€ { }ë¡œ ê°ìŒˆ
            let result = "";
            tokenList.forEach(t => {
                if (t.type === 'word' && t.selected) {
                    result += `{${t.text}}`;
                } else {
                    result += t.text;
                }
            });

            document.getElementById('edited_content').value = result;
            document.getElementById('edit-form').submit();
        }

        // ì´ˆê¸° ì‹¤í–‰
        parseText(rawContent);


    // [B] ê²Œì„ ëª¨ë“œ ë¡œì§
    {% else %}
        const inputs = document.querySelectorAll('.quiz-input');
        const xpDisplay = document.getElementById('xp-display');
        const submitBtn = document.getElementById('submit-btn');
        let currentXP = {{ session['xp'] }};
        let penaltyCount = 0;

        inputs.forEach(input => {
            // ì…ë ¥ ì™„ë£Œ ì‹œì  (ì—”í„°, í¬ì»¤ìŠ¤ ì•„ì›ƒ)
            input.addEventListener('change', function() {
                validate(this);
                checkAll();
            });
            
            // ì—”í„°í‚¤ ì²˜ë¦¬
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    this.blur(); // change ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
                    focusNext(this);
                }
            });
        });

        function validate(input) {
            const val = input.value.trim();
            const ans = input.dataset.answer;
            const wrapper = input.parentElement;

            if (input.classList.contains('correct')) return; // ì´ë¯¸ ì •ë‹µì´ë©´ íŒ¨ìŠ¤
            if (val === '') { // ë¹„ì–´ìˆìœ¼ë©´ ì´ˆê¸°í™”
                input.classList.remove('error');
                wrapper.classList.remove('show-hint');
                return;
            }

            if (val === ans) {
                // ì •ë‹µ
                input.classList.remove('error');
                input.classList.add('correct');
                input.readOnly = true;
                wrapper.classList.remove('show-hint');
                updateXP(5); // +5 XP
            } else {
                // ì˜¤ë‹µ
                input.classList.add('error');
                wrapper.classList.add('show-hint');
                updateXP(-5); // -5 XP
                penaltyCount++;
                document.getElementById('penalty_count').value = penaltyCount;
            }
        }

        function updateXP(amount) {
            currentXP += amount;
            xpDisplay.innerText = currentXP;
            
            // ì‹œê° íš¨ê³¼
            const effect = document.createElement('span');
            effect.innerText = amount > 0 ? `+${amount}` : amount;
            effect.style.position = 'fixed';
            effect.style.color = amount > 0 ? '#2ecc71' : '#ff4444';
            effect.style.fontWeight = 'bold';
            effect.style.fontSize = '1.5rem';
            
            const rect = xpDisplay.getBoundingClientRect();
            effect.style.left = rect.left + 'px';
            effect.style.top = (rect.top - 30) + 'px';
            effect.style.transition = '1s';
            
            document.body.appendChild(effect);
            setTimeout(() => {
                effect.style.top = (rect.top - 60) + 'px';
                effect.style.opacity = 0;
            }, 50);
            setTimeout(() => effect.remove(), 1000);
        }

        function checkAll() {
            const allCorrect = Array.from(inputs).every(i => i.classList.contains('correct'));
            if (allCorrect) {
                submitBtn.disabled = false;
                submitBtn.style.background = "#2ecc71";
                submitBtn.style.cursor = "pointer";
                submitBtn.innerText = "ğŸ‰ í€˜ìŠ¤íŠ¸ ì™„ë£Œ! ë³´ìƒ ë°›ê¸°";
            }
        }

        function checkFinal() {
            document.getElementById('game-form').submit();
        }

        function focusNext(curr) {
            const arr = Array.from(inputs);
            const idx = arr.indexOf(curr);
            if (idx < arr.length - 1) {
                for(let i=idx+1; i<arr.length; i++){
                    if(!arr[i].readOnly) {
                        arr[i].focus(); 
                        break;
                    }
                }
            }
        }
    {% endif %}
</script>
{% endblock %}
